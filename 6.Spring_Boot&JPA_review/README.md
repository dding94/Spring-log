# 복습하면서 여태 배웠던 필요한 개념 정리

jar? , war?
- jar
  - Jar는 항상 내장 서버(톰캣등)을 사용하고, `webapp` 경로도 사용하지 않습니다.
  - 내장서버에 최적화 되어 있는 기능.
- war
  - war를 사용하면 내장 서버도 사용가능하지만 주로 외부 서버에 배포하는 목적으로 사용

스프링 Bean 이란?
- spring IoC 컨테이너가 관리하는 자바 객체를 빈(Bean) 이라는 용어로 부른다.

@Controller
- 스프링이 자동으로 스프링 빈으로 등록
- 반환값이 `string` 이면 뷰 이름으로 인식. 그래서 뷰를 찾고 뷰가 렌더링
- 주로 서비스를 가져다 씀
- 커맨드성(주문 등 핵심비즈니스 로직)은 식별자만 넘겨주고 서비스에서 엔티티를 찾는거 부터 해야 영속상태로 진행되고 관리하기 좋다(값 수정에 용이).
  - 컨트롤러에서 처리하면 트랜잭션없이 조회했기 때문에 영속성상태가 아니게 된다.
  
@ResponseBody
- View 조회를 무시하고 HTTP message Body에 직접 해당 내용 입력

@RestController
- @Controller 와 @ResponseBody의 조합
- 반환 값으로 뷰를 찾는 것이 아닌, HTTP 메시지 바디에 바로 입력
- 단순히 객체 데이터(json, xml)를 반환
- Restful API를 개발할 때 주로 사용 (왜? body에 데이터를 담기 때문)

@RequestMapping
- 요청 정보를 매핑한다. 해당 URL이 호출되면 이 메서드가 호출된다.
- 요청받을 url 와 어떤 요청을 받을지 정의한다(GET, POST, PUT, DELETE) 등

@Repository
- 자동으로 빈에 등록 Component scan 의 대상이 된다.

@Id
- 테이블의 주키(primary key) 역할을 한다는 것을 나타냄

@GeneratedValue
- 주키의 값을 위한 자동 생성 전략을 명시하는데 사용, default 값은 AUTO 이다.

@PersistenceContext
- 스프링이 알아서 엔티티매니저 주입

@ModelAttribute
- 바인딩을 받는 객체를 생성
- 요청 파라미터의 이름으로 객체의 프로퍼티를 찾는다. 그리고 해당 프로퍼티의 setter를 호출해서 파라미터 값을 입력
  - getter, setter가 만들어져 있어야 함.
- 이 애노테이션이 붙은 객체가 자동으로 Model객체에 추가되고 뷰로 전달

@PathVariable(경로 변수)
- ex) /mapping/userA or /users/{user} 같이 리소스 경로에 식별자가 있음
- `@RequestMapping` 은 URL 경로를 템플릿화 => `{템플릿변수}` 를 사용하는데 이 변수를 가져올 때 사용

@RequestParam
- 쿼리스트링을 사용하여 여러개의 값을 전달하는 방식을 받아올때 주로 사용
- uri를 통해 전달된 값이 아니더라도, ajax 요청을 통해 body에 담아온 데이터를 여러 타입으로 받을 수도 있다.


Entity 란
- Entity 클래스는 실제 데이터베이스의 테이블과 1:1로 매핑되는 클래스로 DB의 테이블내에 존재하는 컬럼만을
속성으로 가져야함.

영속성 저장 메소드에서 아이디값을 넘기는 이유
- return member.getId(); //커맨드랑 쿼리랑 분리해라.

JPA 영속성 컨텍스트 쓰는 이유?
- 1차 캐시
  - 1차 캐시에서 바로 조회 가능, 1차캐시가 없으면 DB에서 조회하여 1차 캐시에 올려 놓는다.
- 동일성(==) 보장
  - 같은 트랜잭션안에서는 같은 엔티티를 반환한다.
- 쓰기지연
  - 트랜잭션을 지원하는 쓰기 지연 커밋 전까지 SQL을 바로 보내지 않는다.
  - 데이터베이스에 테이블 로우에 락이 걸리는 시간 최소화
- 지연로딩
  - 엔티티에서 해당 엔티티를 불러오는 그 때 SQL을 날려 해당 데이터를 가져온다.
- 변경감지(Dirty checking)
  - 영속성 엔티티 데이터 수정 후 커밋을 하면 기존 스냅샷과 비교해서 커밋때 JPA가 업데이트 쿼리도 자동으로 보냄
  
임베디드 타입
- 새로운 값 타입을 직접 정의할 수 있음.
- JPA는 임베디드 타입이라함
- 주로 기본 값 타입을 모아 만들어서 복합 값 타입이라고도 함
- `@Embeddable`: 값 타입을 정의하는 곳에 표시
- `@Embedded`: 값 타입을 사용하는 곳에 표시
- [참고] 값 타입은 변경 불가능 하게 설계해야 한다. JPA 스펙상 엔티티나 임베디드 타입은 자바 기본생성자를 `pulbic` 또는 
`protected` 로 설정해야한다. JPA가 이런 제약 을 두는 이유는 JPA 구현 라이브러리가 객체를 생성할 때 리플랙션 같은 기술을 사용할 수 있도록 지원해야하기 때문


★1:N 관계에서 N 쪽에 외래키가 있고 외래키가 있는 N을 연관관계의 주인으로 정한다.

연관관계 필요한 이유?
- 객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것

`★연관관계 주인
`- 객체의 두 관계중 하나를 연관관계의 주인으로 지정
- 주인이 아닌쪽은 읽기만 가능하다 mappedBy 속성으로 주인을 지정
- 연관관계의 주인만이 외래 키를 관리(등록, 수정)

★중요 모든 연관관계는 지연로딩(`LAZY`)으로 설정!
- 즉시로딩(`EAGER`)은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다.
- 특히 JPQL을 실행할 때 N+1 문제가 자주 발생한다.
- 연관된 엔티티를 함께 DB에서 조회해야 하면 `fetch join` 또는 엔티티 그래프 기능을 사용한다.

양방향 연관관계 주의!
- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정
- 연관관계 편의 메소드를 생성하자.

상속관계 매핑 주요 어노테이션
- @Inheritance : 상속관계 전략 지정,부모 클래스에 잡아야함. 
  - `JOINED`, `SINGLE_TABLE` , `TABLE_PER_CLASS` 가 있음
- @DiscriminatorColum(name="DTYPE")
  - 부모 클래스에 선언, 하위 클래스를 '구분' 하는 용도
- @DiscriminatorValue("XXX")
  - 하위 클래스에 선언, 엔티티를 저장할 때 슈퍼타입의 구분 컬럼에 저장할 값을 지정

@Enumerated(EnumType.STRING)
- 자바 enum 타입을 매핑할 때 사용 String 안하고 중간에 값이 들어가면 데이터가 밀릴 수 있음

@Transactional
- 데이터 변경하는 곳에 있어 트랜잭션이 필요하다.
- readOnly 옵션: 읽기 전용(조회하는데에서 성능 최적화) 읽기하는곳에서는 가급적 사용!

영속성 전이(CASCADE)
- 특정 엔티티에 대해 특정한 작업을 수행하면 관련된 엔티티에도 동일한 작업을 수행한다.
- 하나의 부모가 자식들을 관리할 때(단일 엔티티에 종속적인 경우)
- 라이프사이클이 같을 때, 단일 소유자

트랜잭션?
- 데이터베이스의 상태를 변경하는 작업 또는 한번에 수행되어야 하는 연산들을 의미
- begin, commit 을 자동으로 수행 해준다.
- 예외 발생 시 rollback 처리를 자동으로 수행
- ACID 성질을 가지고 있다.
  - Atomicity(원자성): 한 트랜잭션 내에서 실행한 작업들은 하나의 단위로 처리. 모두 성공 or 모두 실패
  - Consistency(일관성): 트랜잭션은 일관성 있는 데이터베이스 상태를 유지
  - Isolation(고립성): 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장
  - Durability(영속성): 트랜잭션을 성공적으로 마치면 결과가 항상 저장되어야 한다.

DI(의존 관계 주입) ?
- 애플리케이션 실행 시점에 외부에서 실제 구현한 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제
의존 관계가 연결 되는 것
- 객체의 생성과 사용의 관심을 분리하는 것
- 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 인스턴스 타입을 변경할 수 있다.

DI 종류
- 생성자 주입
  - 생성자 호출시점에 딱 1번만 호출되는 것이 보장. 불변, 필수 의존관계 사용
  - 애플리케이션을 실행하고 의존관계를 바꿀일이 거의 없음.
  - final 키워드 사용
- 수정자 주입(setter 주입)
  - 선택, 변경 가능성이 있는 의존관계에 사용
- 필드 주입
  - 외부에서 변경이 불가능하여 테스트 하기 힘듬.
- 일반 메서드 주입

도메인 모델 패턴
- 엔티티가 비즈니스 로직을 가지고 객체 지향의 특성을 적극 활용
- 응집도, 관리하기 쉬움
- 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할

@Setter 를 사용하기 보다 핵심비즈니스를 통해 값을 변경하자.
- 생성자 오버로딩
- Builder 패턴
- 정적 팩토리 메서드 << 주로사용

복잡한 생성은 별도의 생성메서드가 있으면 좋다. (정적 팩토리 메서드 패턴)
- 가독성이 좋다.
- 호출할 때마다 새로운 객체를 생성할 필요가 없다.
- 하위 자료형 객체를 반환할 수 있다.
- 형인자 자료형 객체를 만들 때 편리하다.
- 추적 용이

Spring boot Validation 적용
- [참고] 2.3이상부터 validation 없으면 직접 추가해야함
- `implementation 'org.springframework.boot:spring-boot-starter-validation'`

유효성 검사
- 검증 애노테이션 
  - @NotNull: null만 허용하지 않으며 빈 문자열("") or 공백(" ")은 허용한다.
  - @NotEmpty: null과 ""을 허용하지 않으며, 공백(" ")은 허용한다.
  - @NotBlank: null, 빈 문자열(""), 공백(" ") 모두 허용하지 않는다.
  - 기타 애노테이션은 https://www.baeldung.com/javax-validation 에 있다.
- 컨트롤러에서 `@Valid` 와 `BindingResult` 를 사용하여 컨트롤러에서 에러를 처리 할 수 있다.
- 유효성 검증에 실패하는 경우 에러 정보가 `BindingResult` 변수에 담겨진다.

__redirect__
- 말 그대로 다시(re) 지시하다(direct) 라는 의미.
- 새로고침으로 인한 중복이 일어나 결과가 바뀌면 안되는 경우에는 redirect를 사용한다.
- PRG: Post/Redirect/Get 방법이 있다.
  - POST 로 결과 화면은 GET 메서드로 리다이렉트
  - 새로고침이 이루어 져도 GET으로 조회하기 때문에 결과가 똑같다.

엔티티를 최대한 순수하게 유지해야 한다.
- 핵심 비즈니스로직에만 의존적이게 하자
- 엔티티를 폼으로 되도록 사용하지는 말자
  - 화면을 위한 로직은 없어야 한다.
  - 화면종속적인 기능이 계속 생겨 지저분해짐
  - 유지보수가 어려움
- 폼객체나 DTO를 활용하면 된다.

API를 만들때는 엔티티를 절대 외부로 반환하면 안된다.
- 엔티티에 필드가 추가되면 API의 스펙이 변한다.
- 템플릿엔진은 선택적으로 사용

### 준영속 엔티티를 수정하는 방법 - 중요!
1. 변경 감지 기능 사용 - 얘만 사용한다고 생각!!!
   - 영속성 컨텍스트에서 엔티티를 다시 조회한 후에 데이터를 수정하는 방법
   - 트랜잭셕 안에서 엔티티를 다시 조회, 변경할 값 선택 => 트랜잭션 커밋 시점에 변경감지(Dirty Checking)이
   동작해서 데이터베이스에 UPDATE SQL 실행
2. 병합(merge) 사용
   - 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용하는 기능
   - 영속 엔티티의 값을 준영속 엔티티의 값으로 모.두 교체한다.
   - 여기서 모든 속성이 변하기 때문이 병합하는 값이 존재하지 않으면 `null` 로 업데이트 한다.

