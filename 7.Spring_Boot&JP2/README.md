# 출처
https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-API%EA%B0%9C%EB%B0%9C-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94/dashboard
- 강사 : 김영한님

# 핵심정리
## 실전! 스프링 부트와 JPA 활용2 - API 성능 최적화

### API 개발 기본
회원 등록 API
- 조회 v1: 응답 값으로 엔티티를 직접 외부에 노출
- 문제점
  - 기본적으로 엔티티의 모든 값이 노출
  - 엔티티가 변경되면 API 스펙이 변한다.
  - 엔티티에 프레젠테이션 계층을 위한 로직이 추가된다.
- 결론
  - API 응답 스펙에 맞추어 별도의 DTO 생성하자.
  - DTO를 사용하면 엔티티가 변해도 API의 스펙이 변하지 않는다.
  - 추가로 `Result` 클래스로 컬렉션을 감싸서 향후 필요한 필드를 추가할 수 있다.

회원 수정 API
- 여기에서는 회원 정보 부분업데이트가 진행되는데 PUT방식을 사용하였다. PUT은 전체 업데이트 할 때 스고,
부분 업데이트는 PATCH나 POST를 사용하는 것이 REST 스타일에 맞다.

회원 조회 API
- V1 버전
  - 엔티티를 반환하는데 @JsonIgnore를 써서 원하지 않은 정보를 뺄 수 있지만 다른 API에서는 해당 정보를 요구할
  수도 있다.
  - 엔티티에 가각가의 API를 위한 모든 요청 요구사항을 담기는 어렵다.
- V2
  - API 스펙이 곧 DTO 코드랑 1:1 매칭

### API 개발 고급 - 지연 로딩과 조회 성능 최적화

간단한 주문 조회 V1: 엔티티를 직접 노출
- 엔티티를 직접 노출하는 것은 좋지 않다!
- order -> member  와 order -> address 는 지연 로딩이다. 따라서 실제 엔티티 대신에 프록시 존재
- jackson 라이브러리는 기본적으로 이 프록시 객체를 json으로 어떻게 생성해야하는지 모름 => 예외 발생
- Hibernate5Module 을 스프링 빈으로 등록하면 해결(부트 사용중)
- 이 옵션을 키면 양뱡향 연관관계를 계속 로딩, 따라서 `@JsonIgnore` 옵션을 한곳에 주어야 한다.

주의 : 엔티티를 직접 노출할 때는 양방향 연관관계가 걸린 곳 중 한곳은 `@JsonIgnore` 처리 해야한다. 안그러면 무한루프 발생 

참고로 간단한 애플리케이션이 아니면 엔티티 노출하지 않는게 좋다. `Hibernate5Module`를 사용하기 보다 DTO로 변환해서 반환하는 것이 더 좋은 방법

지연 로딩(LAZY)를 피하기 위해 즉시 로딩(EAGER)로 설정하면 안된다! 즉시 로딩 때문에 연관관계가 필요 없는 경우에도 데이터를 항상 조회해서 성능 문제를
발생할 수 있다. 즉시 로딩으로 설정하면 성능 튜닝이 매우 어려워 진다. 항상 지연 로딩을 기본으로 하고, 성능 최적화가 필요한 경우에는
페치 조인(fetch join)을 사용!

간단한 주문 조회 V2: 엔티티를 DTO로 변환
- 엔티티를 DTO로 변환하는 일반적인 방법 사용.
- 쿼리가 1 + N + N 번 실행 (v1과 쿼리수 결과는 같다)
- `order` 조회 1번 (order 조회 결과 수가 N이 된다.)
- `oredr -> member` 지연 로딩 조회 N번
- `order -> delivery` 지연 로딩 조회 N번
- 예) order 의 결과가 4개면 최악의 경우 1 + 4 + 4번 실행(최악의 경우)
  - 지연로딩은 영속성 컨텍스트에서 조회하므로, 이미 조회된 경우 쿼리를 생략한다.

간단한 주문 조회 V3: 엔티티를 DTO로 변환 - 페치 조인 최적화
- 엔티티를 페치 조인을 사용해서 쿼리 1번에 조회
- 페치 조인으로 `order -> member` , `order -> delivery` 는 이미 한번에 조회 된 상태 이므로 지연로딩 X

간단한 주문 조회 V4: JPA에서 DTO로 바로 조회
- 일반적인 SQL을 사용할 떄 처럼 원하는 값을 선택해서 조회
- `new` 명령어를 사용해서 JPQL의 결과를 DTO로 즉시변환
- SELECT 절에서 원하는 데이터를 직접 선택하므로 DB -> 애플리케이션 네트워크 용량 최적화(생각보다 미미)
- 조회 전용 리포지토리로 분리함.
  - 리포지토리 재사용성이 떨어지고, API스펙에 맞춘 코드가 리포지토리에 들어가기때문에 분리

__정리__
- 엔티티를 DTO로 반환하거나 DTO로 바로 조회하는 두 가지 방법은 각각 장단점이 있다. 상황에 따라서
더 나은 방법을 선택, 엔티티로 조회하면 리포지토리 재사용성도 좋고, 개발도 단순해짐

쿼리 방식 선택 권장 순서
1. 우선 엔티티를 DTO로 변환하는 방법을 선택
2. 필요하면 페치 조인으로 성능을 최적화 => 대부분 성능 이슈 해결
3. 그래도 안되면 DTO로 직접 조회하는 방법 사용
4. 최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해서 SQL을 직접 사용

### API 개발 고급 - 컬렉션 조회 최적화
일대다 관계(OneToMany)를 조회하고, 최적화 하는 방법을 알아보자.

주문 조회 V1: 엔티티 직접 노출
- `orderItem`, `item` 관꼐를 직접 초기화 하면 `Hibernate5Module` 설정에 의해 엔티티를 JSON으로 생성
- 양방향 연관관계면 무한 루프에 걸리지 않게 한곳에 `@JsonIgnore` 를 추가해야 한다.
- 하지만 엔티티를 직접 노출하기 때문에 좋은 방법은 아니다.
