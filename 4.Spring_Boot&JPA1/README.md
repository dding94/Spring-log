# 출처
https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-%ED%99%9C%EC%9A%A9-1/dashboard
강사 : 김영한님

# 핵심정리
## 실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발

### 프로젝트 환경설정
- 프로젝트 생성 ~ JPA와 DB설정, 동작 확인

## 도메인 분석 설계

<details><summary>기능 목록</summary> 

회원 기능
- 회원 등록
- 회원 조회

상품 기능
- 상품 등록
- 상품 수정
- 상품 조회

주문 기능
- 상품 주문
- 주문 내역 조회
- 주문 취소

기타 요구사항
- 상품은 재고 관리가 필요하다.
- 상품의 종류는 도서, 음반, 영화가 있다.
- 상품을 카테고리로 구분할 수 있다.
- 상품 주문시 배송 정보를 입력할 수 있다.
</details>

### 도메인 모델과 테이블 설계
![image](https://user-images.githubusercontent.com/21376853/152526883-14965d4f-abba-4abc-8556-580fbe6ff5aa.png)
<details><summary> 도메인 모델과 테이블 설계 자세히 </summary>

회원, 주문, 상품의 관계
- 회원은 여러 상품을 주문할 수 있다.
- 한 번 주문할 때 여러 상품을 선택할 수 있으므로 주문과 상품은 다대다 관계다.
- 하지만 이런 다대다 관계는 관계형 데이터베이스는 물론이고 엔티티에서도 거의 사용하지 않는다.
- 따라서 그림처럼 주문상품이라는 엔티티를 추가해서 다대다 관계를 일대다, 다대일 관계로 풀어냈다.

상품 분류
- 상품은 도서, 음반, 영화로 구분되는데 상품이라는 공통 속성을 사용하므로 상속 구조로 표현했다.

</details>

__회원 엔티티 분석__   
![image](https://user-images.githubusercontent.com/21376853/152527262-b4417730-15f3-4541-aef6-93e800ed5ff6.png)
<details><summary> 회원 엔티티 분석 자세히 </summary>

회원(Member)
- 이름과 임베디드 타입인 주소(`Address`), 그리고 주문(`order`) 리스트를 가진다.

주문(Order)
- 한 번 주문시 여러 상품을 주문할 수 있으므로 주문과 주문상품(`OrderItem`)은 일대다 관계다. 주문은 상품을 주문한 회원과 배송 정보, 주문 날짜,
  주문 상태(`status`)를 가지고 있다. 주문 상태는 열거형을 사용했고 주문(`ORDER`), 취소(`CANCEL`)을 표현할 수 있다.

주문상품(OrderItem)
- 주문한 상품 정보와 주문 금액(`orderPrice`), 주문 수량(`count`) 정보를 가지고 있다. (보통 `OrderLine`, `LineItem` 으로 많이 표현한다.)

상품(Item)
- 이름, 가격, 재고수량(`sotckQuantity`)을 가지고 있다. 상품을 주문하면 재고수량이 줄어든다. 상품의 종류로는 도서, 음반, 영화가 있는데
  각각은 사용하는 속성이 조금씩 다르다.

배송(Delivery)
- 주문시 하나의 배송 정보를 생성한다. 주문과 배송은 일대일 관계다.

카테고리(Category)
- 상품과 다대다 관계를 맺는다. `parent`, `child`로 부모, 자식 카테로기를 연결한다.

주소(Address)
- 값 타입(임베디드 타입)이다. 회원과 배송(Delivery)에서 사용한다.
</details>


__회원 테이블 분석__   
![image](https://user-images.githubusercontent.com/21376853/152528812-7c96dae4-3924-4fa3-b5ba-4b444246c432.png)
<details><summary> 회원 테이블 분석 자세히 </summary>

[참고]
- 테이블명이 `ORDER`가 아니라 `ORDERS`인 것은 데이터베이스가 `order by` 때문에 예약어로 잡고 있는 경우가 많다.
- 실제 코드에서는 DB에 소문자 + _ (언더스코어) 스타일을 사용한다.

MEMBER
- 회원 엔티티의 `Address` 임베디드 타입 정보가 회원 테이블에 그대로 들어갔다. 이것은 `DELIVERY` 테이블도 마찬가지다.

ITEM
- 앨범, 도서, 영화 타입을 통해서 하나의 테이블로 만들었다. `DYTPE` 컬럼으로 타입을 구분한다.

__연관관계 매핑 분석__

회원과 주문
- 일대다, 다대일의 양방향 관계.
- 외래 키가 있는 주문을 연관관계의 주인으로 정하는 것이 좋다.
- `Order.member`를 `ORDERS.MEMBER_ID` 외래 키와 매핑한다.

주문상품과 주문
- 다대일 양방향 관계. 외래 키가 주문상품에 있으므로 주문상품이 연관관계의 주인
- `OrderItem.order`를 `ORDER_ITEM.ORDER_ID` 외래 키와 매핑


주문상품과 상품
- 다대일 단방향 관계다.
- `OrderItem.item`을 `ORDER_ITEM.ITEM_ID` 외래 키와 매핑한다.

주문과 배송
- 일대일 양방향 관게다.
- `Order.delivery`를 `ORDERS.DELIVERY_ID` 외래 키와 매핑한다.

카테고리와 상품
- `@ManyToMany` 를 사용해서 매핑한다(실무에서는 @ManyToMany 사용 X, 여기서는 예제로 보여주기 위함)

</details>

[참고] : 외래 키가 있는 곳을 연관관계의 주인으로 정해라.
- 연관관계의 주인은 단순 외래 키를 누가 관리하냐의 문제이지 비즈니스상의 우위에 있다고 주인으로 정하면 안된다.
- 일대다 관계에서 항상 다쪽에 외래 키가 있으므로 외래키에 있는 쪽을 연관관계의 주인으로 정하면 된다.


## 엔티티 클래스 개발
- 실무에서는 가급적 Getter는 열어두고, Setter는 꼭 필요한 경우에만 사용하자
- 엔티티의 데이터 조회할 일이 너무 많아 Getter는 열어두는 것이 편리하다. Getter를 호출 해서 어떤일이 발생하지는 않는다.
- Setter는 데이터가 변해 유지보수가 힘들어진다.
- 엔티티를 변경할 때는 Setter 대신에 변경 지점이 명확하도록 변경을 위한 메서드를 별도로 제공해야 한다.

### 회원 엔티티 - Member class
- 엔티티의 식별자는 `id`를 사용하고 PK 컬럼명은 `member_id`를 사용.
- 엔티티는 타입이 있으므로 `id` 필드만으로 쉽게 구분할 수 있지만 테이블은 타입이 없어 구분이 힘듬.
- 테이블은 관례상 `테이블명 + id`를 많이 사용

### 주소 값 타입 - Address class
- `@Setter`를 제거, 생성자에서 값을 모두 초기화해서 변경 불가능한 클래스를 만들자.
- JPA 스펙상 엔티티나 임베디드 타입(`@Embeddable`)은 자바 기본 생성자를 `pulbic` 또는 `protected`로 설정해야한다
- JPA가 이런 제약을 두는 이유는 JPA 구현 라이브러리가 객체를 생성할 때 리플랙션 같은 기술을 사용할 수 있도록 지원해야 하기 때문이다.

## 엔티티 설계시 주의점

__엔티티에는 가급적 Setter를 사용하지 말자__   
- Seeter가 열려있으면 변경 포인트가 너무 많아서 유지보수가 어렵다. 

__★★모든 연관 관계는 지연로딩으로 설정!★★__
- 즉시로딩(`EAGER`)은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다. 특히 JPQL을 실행할 때 N+1 문제가 자주 발생한다.
- 실무에서 모든 연관관계는 지연로딩(`LAZY`)으로 설정해야 한다.
- 연관된 엔티티를 함께 DB에서 조회해야 하면, fetch join 또는 엔티티 그래프 기능을 사용한다.
- @XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야 한다.

__컬렉션은 필드에서 바로 초기화 하자__
- 컬렉션은 필드에서 바로 초기화 하는것이 안전
- `null` 문제에서 안전하다.
- 하이버네이트는 엔티티를 영속화 할 때, 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변견한다. 만약 `getOrders()` 처럼
임의의 메서드에서 컬렉션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다. 따라서 필드레벨에서 생성하는 것이 안전하고, 코드도 간결하다.

### 회원 리포지토리 개발
기술 설명
- `@Repository` : 스프링 빈으로 등록, JPA 예외를 스프링 기반 예외로 예외 변환
- `@PersistenceContext`: 엔티티 메니저(`EntityManager`) 주입
- `@PersistenceUnit`: 엔티티 매니저 팩토리(`EntityManagerFactory`) 주입
- `em.Persist(member)` : 영속성 컨텍스트에 객체를 넣고 트랜젝션이 커밋되는 시점에 DB예 반영
- `jpql`: from 대상이 테이블 이아닌 엔티티가 대상 

### 회원 서비스 개발
기술 설명
- `@Transactional`: 트랜잭션, 영속성 컨텍스트
  - `readOnly=ture`: 데이터의 변경이 없는 읽기 전용 메서드에 사용, 영속성 컨텍스트를 플러시 하지 않으므로 약간의 성능 향상(읽기 전용에는 다 적용)
  - 데이터베이스 드라이버가 지원하면 DB에서 성능 향상
- `@Autowired`
  - 생성자 Injection 많이 사용, 생성자가 하나면 생략 가능

스프링은 필드 주입 대신에 생성자 주입을 사용하자.
- 변경 불가능한 안전한 객체 생성 가능
- 생성자가 하나면 , `Autowired` 생략 할 수 있다.
- `final` 키워드를 추가하면 컴파일 시점에 `memberRepository`를 설정하지 않는 오류를 체크 할 수 있다.
- 참고 : 스프링 데이터 JPA를 사용하면 `EntityManager`도 주입 가능

### 회원 기능 테스트
테스트 요구사항
- 회원가입을 성공해야 한다.
- 회원가입 할 때 같은 이름이 있으면 예외가 발생해야 한다.

기술 설명
- `@SpringBootTest`: 스프링 부트를 띄우고 테스트한다.(이게 없다면 `@Autowired` 실패)
- `@Transactional`: 반복 가능한 테스트 지원, 각각의 테스트를 실행할 때 마다 트랜젝션을 시작하고 테스트가 끝나면 트랜젝션을 강제로 롤백(이 어노테이션
이 테스트 케이스에서 사용될 때만 롤백)
- `assertThrows`: 메서드를 실행할 때 지정한 예외가 나오는지 체크한다.

테스트 케이스를 위한 설정
- Test 폴더 아래 resources 디렉토리를 만들고 application.yml 설정을 메모리 DB를 사용하도록 설정하면 된다.
- 별도의 설정이 없어도 스프링은 기본적으로 메모리 DB를 사용한다.


## 상품 도메인 개발

### 상품 엔티티 개발 (비즈니스 로직 추가)
[팁]: 데이터가있는 쪽에 비즈니스 로직이 있으면 응집력이 좋고, 유지보수에 좋다. 객체지향프로그래밍을 활용한다 라고 말할 수 있다.

비즈니스 로직 분석
- `addStock()` 메서드는 파라미터로 넘어온 수만큼 재고를 느린다. 이 메서드는 재고가 증가하거나 상품 주문을 취소해서 재고를 다시 늘려야 할 때 사용한다.
- `removeStock()` 메서드는 파라미터로 넘어온 수만큼 재고를 줄인다. 만약 재고가 부족하면 예외가 발생한다. 주로 상품을 주문할 때 사용

### 상품 리포지토리 개발
기능 설명
- `Save()`
  - `id`가 없으면 신규로 보고 `persist()`실행
  - `id`가 있으면 이미 데이터베이스에 저장된 엔티티를 수정한다고 보고 `merge()`를 실행

### 상품 서비스 개발

saveItem 메서드에 `@Transactional`을 해야 저장이 됨. 클래스 레벨에 readOnly=true 이기 때문

## 주문 도메인 개발

### 주문 엔티티 개발
기능설명
- 생성 메서드(`createOrder()`): 주문 엔티티를 생성할 때 사용한다. 주문 회원, 배송정보, 주문상품의 정보를 받아 실제 주문 엔티티를 생성한다.
- 주문 취소(`cancel()): 주문 취소시 사용. 주문 상태를 취소로 변경하고 주문상품에 주문 취소를 알림. 만약 이미 배송을 완료한 상품이면 주문 취소하지 못하게
예외를 발생시킨다.
- 전체 주문 가격 조회: 주문 시 사용한 전체 주문 가격을 조회.

### 주문상품 엔티티 개발
- 생성 메서드(`createOrderItem()): 주문 상품, 가격, 수량 정보를 사용해서 주문상품 엔티티를 생성한다.
그리고 `item.removeStock(count)`를 호출해서 주문한 수량만큼 상품의 재고를 줄인다.
- 주문 취소(`cancel()`): `getItem().addStock(count)`를 호출해서 취소한 주문 수량만큼 상품의 재고를 증가시킨다.
- 주문 가격 조회(`getTotalPrice()`): 주문 가격에 수량을 곱한 값을 반환한다.

### 주문 리포지토리 개발

### 주문 서비스 개발
- 주문(`order()`): 주문하는 회원 식별자, 상품 식별자, 주문 수량을 정보를 받아서 실제 주문 엔티티를 생성한 후 저장한다.
- 주문 취소(`cancelOrder()`): 주문 식별자를 받아서 주문 엔티티를 조회한 후 주문 엔티티에 주문 취소를 요청한다.
- 주문 검색(`findOrders()`): `OrderSearch`라는 검색 조건을 가진 객체로 주문 엔티티를 검색한다.

[참고] : 주문 서비스의 주문과 주문 취소 메서드를 보면 비즈니스 로직 대부분이 엔티티에 있다. 서비스 계층은 단순히 엔티티에 필요한 요청을
위임하는 역할을 한다. 이처럼 엔티티가 비즈니스 로직을 가지고 객체 지향의 특성을 적극 활용하는 것을 '도메인 모델 패턴' 이라한다. 반대로 엔티티에는 비즈니스 로직이 거의 없고 서비스 계층에서 대부분의 비즈니스 로직을 처리하는 것을 '트랜잭션 스크립트 패턴' 이라 한다.

### 주문 기능 테스트
테스트 요구사항
- 상품 주문이 성공해야 한다.
  - 주문 후 재고 수량이 정확히 줄었는지 검증한다.
- 상품을 주문할 때 재고 수량을 초과하면 안 된다.
  - 재고 수량을 초과해서 상품을 주문하면 `NotEnoughStockException` 예외가발생해야한다.
- 주문 취소가 성공해야 한다.
  - 주문 취소를 하면 그만큼 재고가 증가해야 한다.

### 주문 검색 기능 개발
JAP 에서 동적 쿼리를 어떻게 해결해야 하는가?
- JPQL 처리 ==> 실무에서 안쓰임, 번거롭고 실수로인한 버그가능성 높음
- JPA Criteria ==> JPA 표준 스펙이지만 실무에서 사용하기에 너무 복잡
- Querydsl 을 사용하면 가장 깔끔하게 해결할 수 있다.

## 웹 계층 개발

### 홈 화면과 레이아웃
스프링 부트 타임리프 기본 설정
- 스프링 부트 타임리프 viewName 매핑
  - `resources:templates/`+{ViewName}+ `.html`
  - `resources:templates/home.html`
  - 반환한 문자(`home`)과 스프링부트 설정 `prefix`, `suffix` 정보를 사용해서 렌더링할 뷰 (`html`)를 찾는다.

부트 스트랩 추가

### 회원 등록
기능정리

`@NotEmpty`
- null 과 "" 둘 다 허용하지 않는다. 
- 값이 비어있으면 오류가 발생

`@Valid`
- 서버측에서 데이터를 바인딩 할때 데이터 유혀성 검증을 할 수 있다.

`BindingResult`
- MemberForm에서 `@NotEmpty`를 사용했기 때문에 name이 없으면 오류가 발생한다.
- `@Valid` 에서 검증할 때 BindingResult 오류가 담겨서 코드가 실행이 된다.

### 회원 목록 조회

참고 :타임리프에서 ? 를 사용하면 `null`을 무시한다.

폼 객체 vs 엔티티 직접 사용
- 요구사항이 정말 단순할 때는 폼 객체(`MemberForm`) 없이 엔티티(`Member`)를 직접 등록과 수정화면에서 사용해도 된다.
하지만 요구사항이 복잡해지기 시작하면, 엔티티에 화면을 처리하기 위한 기능이 점점 증가한다. 결과적으로 엔티티는 점점 화면에 종속적으로 변하고,
화면 기능 때문에 지저분해진 엔티티는 결국 유지보수하기 어려워진다.
- 실무에서 __엔티티는 핵심 비즈니스 로직만 가지고, 화면을 위한 로직은 없어야한다.__ 화면이나 API에 맞는 폼 객체나
DTO를 사용하자. 그래서 화면이나 API 요구사항을 이것들로 처리하고, 엔티티는 최대한 수수하게 유지!

### 상품 등록
- 상품 등록 폼에서 데이터를 입력하고 Submit 버튼을 클릭하면 `/items/new`를 POST 방식으로 요청
- 상품 저장이 끝나면 상품 목록 화면(`redirect:/items`) 으로 리다이렉트
- `itemController` 에서 book을 만들 때 실무에선 set을 지운다. 나중에 개인 프로젝트하면서 바꿔보기

### 상품 목록
- `model` 에 담아둔 상품 목록인 `items`를 꺼내서 상품 정보를 출력

### 상품 수정

상품 수정 폼 이동
1. 수정 버튼을 선택하면 `/items/{itemId}/edit` URL을 GET 방식으로 요청
2. 그 결과로 `updateItemForm()` 메서드를 실행하는데 이 메서드는 `itemService.findOne(itemId)`를 호출해서 수정할 상품을 조회
3. 조회 결과를 모델 객체에 담아서 뷰 (`items/updateItemForm`)에 전달

상품 수정 실행
1. 상품 수정 폼에서 정보를 수정하고 Submit 버튼을 선택
2. `/items/{itemId}/edit` URL을 POST 방식으로 요청하고 `updateItem()` 메서드를 실행
3. 이때 컨트롤러에 파라미터로 넘어온 `item` 엔티티 인스턴스는 현재 준영속 상태이다. 따라서 영속성 컨텍스트의 지원을 받을 수 없고 데이터를 수정해도
변경 감지 기능은 동작 X

## ★변경 감지와 병합(merger)★
꼭 이해해야한다.

준영속 엔티디?
- 영속성 컨텍스트가 더는 관리하지 않는 엔티티를 말한다.
- 여기서는 `itemService.saveItem(book)`에서 수정을 시도하는 `book` 객체다. `book` 객체는 이미 DB에 한번
저장되어서 식별자가 존재한다. 이렇게 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 준 영속 엔티티로 볼 수 있다.

준영속 엔티티를 수정하는 2가지 방법
- 변경 감지 기능 사용
- 병합(`merge`) 사용

변경 감지 기능 사용
- 영속성 컨텍스트에서 엔티티를 다시 조회한 후에 데이터를 수정하는 방법
- 트랜잭션 안에서 엔티티를 다시 조회, 변경할 값 선택 => 트랜잭션 커밋 시점에 변경 감지(Dirty Checking) 이 동작해서 데이터베이스에 
UPDATE SQL 실행

병합 사용
- 병합은 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용하는 기능이다.

![image](https://user-images.githubusercontent.com/21376853/152996889-12f04cb3-e7d6-45d6-b07f-b3ea4b382a65.png)   

병합 동작 방식
1. `merge()`를 실행한다.
2. 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회한다.   
 2-1. 만약 1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고, 1차 캐시에 저장한다.
3. 조회한 영속 엔티티(`mergeMember`)에 `member` 엔티티의 값을 채워 넣는다. (member 엔티티의 모든 값을 mergeMember에 밀어 넣는다. 이때
"회원 1"이라는 이름이 "회원명변경"으로 바뀐다.)
4. 영속 상태인 mergeMember를 반환한다.

병합시 동작 방식을 간단히 정리
1. 준영속 엔티티의 식별자 값으로 영속 엔티티를 조회한다.
2. 영속 엔티티의 값을 준영속 엔티티의 값으로 모두 교체한다.(병합한다.)
3. 트랜잭션 커밋 시점에 변경 감지 기능이 동작해서 데이터베이스에 UPDATE SQL이 실행

[주의]: 변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경된다.
병합시 값이 없으면 `null`로 업데이트 할 위험도 있다.(병합은 모든 필드를 교체)

### 가장 좋은 해결 방법
__엔티티를 변경할 때는 항상 변경 감지를 사용하자!__   
- 컨트롤러에서 어설프게 엔티티를 생성하지 말기
- 트랜잭션이 있는 서비스 계층에 식별자(`id`)와 변경할 데이터를 명확하게 전달하기(파라미터 or dto)
- 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회하고, 엔티티의 데이터를 직접 변경하기
- 트랜잭션 커밋 시점에 변경 감지가 실행

### 상품 주문

주문 폼 이동
- 메인 화면에서 상품 주문을 선택하면 `/order`를 GET 방식으로 호출
- `OrderController` 의 `createForm ()` 메서드
- 주문 화면에는 주문할 고객정보와 상품 정보가 필요하므로 `model` 객체에 담아서 뷰에 넘겨줌

주문 실행
- 주문할 회원과 상품 그리고 수량을 선택해서 Submit 버튼을 누르면 `/order` URL을 POST 방식으로 호출
- 컨트롤러의 `order()` 메서드를 실행
- 이 메서드는 고객 식별자(`memberId`), 주문할 상품 식별자(`itemId`), 수량(`count`) 정보를 받아서 주문 서비스에 주문을 요청
- 주문이 끝나면 상품 주문 내역이 있는 `/orders` URL로 리다이렉트
- [팁] 커맨드성 주문 등등 외부 컨트롤러에서 식별자만 넘기고 핵심비즈니스 로직이 있는 서비스계층에서 엔티티 조회해서 영속성 상태로 진행 하도록 하는게 좋다.

### 주문 취소
주문 내역 이동
- 메인 화면 에서 주문 내역을 선택하면 `/orders`를 Get 방식으로 호출
- `@ModelAttribute`를 사용하여 상태를 담아준다.

주문 취소
- `@PathVariable` 경로 변수를 사용하여 매칭되는 `orderId`를 가져와 주문취소를 실행하여 리다이렉트 한다.
